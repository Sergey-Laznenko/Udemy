// Объявленная функция VS функциональное выражение


function myFn(a, b) {   //* Объявленная функция
  let c
  a += 1
  c = a + b
  return c
}

// function(x, y) {    //* функциональное выражение НЕЛЬЗЯ использовать автономно
  // let c
  // x += 1
  // c = x + y
  // return c
// }

//! Функциональные выражения всегда АНОНИМНЫ, и чаще всего используется как аргумент в вызове другой функции

//? Присваивание функционального выражения переменной

const myFunction = function(c, d) { // const myFunction - создание переменной, а function(c, d) - создание функционального выражения, другими словами мы вкладываем функцию в переменную, значение переменной myFunction - является анонимное функциональное выражение
  let x
  c += 1
  x = c + d
  return x
}

console.log(myFunction(5, 3))

//? Функциональное выражение в вызове другой функции

setTimeout(function(){  // В функцию в качестве 1го аргументы вкладываем анонимную функцию
  console.log('Отложенное сообщение') // тело анонимной функции
}, 1000) // второй аргумент


//! Стрелочные функции, сразу начинаются с опциональных параметров и не имеет имени

const myFunction2 = (k, l) => { // можно и не присваивать стрелочную функцию переменной
  let c
  k += 1,
  c = k + l
  return c
}

myFunction2(5, 3) // Вызов функции

//! Важно !! Если мы присваиваем стрелочную функцию ИЛИ функциональное выражение переменной, то впоследствии мы НЕ МОЖЕМ переписать значение данной переменной, то есть не можем изменить на другую функцию, в данной переменной... А если мы объявляем функцию(function) и называем её(myFn), то впоследствии сможем присвоить НОВОЕ значение данной переменной, другими словами данной переменной сможем присвоить другую функцию


// Стрелочная функция в вызове другой функции (CallBack)
setTimeout(() => {console.log('Отложенное сообщение')}, 1000)

// Варианты сокращений стрелочной функции

// 1. 
a => { // Если только 1 параметр, то () можно опустить
  // тело функции
}

// 2.
(a, b) => a + b // () можно опустить если тело функции состоит только из одно выражение и НЕЯВНО возвращает результат


//* Значения параметров функций по умолчанию

//* Пример 1

function multByFactory(value, multiplier = 1) { // в параметрах можно передавать значения переменных, для последующих манипуляций внутри функции с их значениями
  return value * multiplier
}

multByFactory(10, 2) 
// 20
multByFactory(5)
// 5


//* Пример 2 неявное возвращение нового объекта без инструкции return, для этого объект обарачиваем в (скобки)

const newPost = (post, addedAt = Date()) => ({ // Параметр 1 - объект, Параметр 2 - Присваиваем стрелочную функцию переменной addedAt и вызываем её
  ...post,
  addedAt, // сокращенная запись, так как совпадает название свойства объекта и название параметра функции
})

const firstPost = {
  id: 1,
  author: 'Sergey',
}

newPost(firstPost)

//! Для неявного возврата переданных параметров функии мы используем (скобки) для того, что бы не создавать дополнительных переменных внутри объекта, которые потом надо будет посредством инструкций возвращать, а мы просто передаём параметры функции, которые в свою очередь возвращаются уже автоматически при её вызове, тем самым добиваяьст универсальности и краткости кода