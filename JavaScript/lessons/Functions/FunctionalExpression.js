// Объявленная функция VS функциональное выражение


function myFn(a, b) {   //* Объявленная функция
  let c
  a += 1
  c = a + b
  return c
}

// function(x, y) {    //* функциональное выражение
  // let c
  // x += 1
  // c = x + y
  // return c
// }

//! Функциональные выражения всегда АНОНИМНЫ, и чаще всего используется как аргумент в вызове другой функции

//? Присваивание функционального выражения переменной

const myFunction = function(c, d) { // const myFunction - сздание переменной, а function(c, d) - создание функционального выражения, другими словами мы вкладываем функцию в переменную, значение переменной myFunction - является анонимное функциональное выражение
  let x
  c += 1
  x = c + d
  return x
}

console.log(myFunction(5, 3))

//? Функциональное выражение в вызове другой функции

setTimeout(function(){  // В функцию в качестве 1го аргументы вкладываем анонимную функцию
  console.log('Отложенное сообщение') // тело анонимной функции
}, 1000) // второй аргумент


//! Стрелочные функции, сразу начинаются с опциональных параметров и не имеет имени

const myFunction2 = (k, l) => { // можно и не присваивать стрелочную функцию переменной
  let c
  k += 1,
  c = k + l
  return c
}

myFunction2(5, 3) // Вызов функции

//! Важно !! Если мы присваиваем стрелочную функцию ИЛИ функциональное выражение переменной, то впоследствии мы НЕ МОЖЕМ переписать значение данной переменной, то есть не можем изменить на другую функцию, в данной переменной... А если мы объявляем функцию(function) и называем её(myFn), то впоследствии сможем присвоить НОВОЕ значение данной переменной, другими словами данной переменной сможем присвоить другую функцию


// Стрелочная функция в вызове другой функции (CallBack)
setTimeout(() => {console.log('Отложенное сообщение')}, 1000)

// Варианты сокращений стрелочной функции

// 1. 
a => { // Если только 1 параметр, то () можно опустить
  // тело функции
}

// 2.
(a, b) => a + b // () можно опустить если тело функции состоит только из одно выражение и НЕЯВНО возвращает результат